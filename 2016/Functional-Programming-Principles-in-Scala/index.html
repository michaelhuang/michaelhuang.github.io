<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Principles in Scala(一) · learn to love less</title><meta name="description" content="Principles in Scala(一) - huangzhf"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://twitter.com/ZhengfeiHuang" target="_blank" class="nav-list-link">TWITTER</a></li><li class="nav-list-item"><a href="https://github.com/michaelhuang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Principles in Scala(一)</h1><div class="post-info">Jun 26, 2016</div><div class="post-content"><p><a href="https://www.coursera.org/learn/progfun1" target="_blank" rel="external">https://www.coursera.org/learn/progfun1</a><br>该课程更像是Scala版本的SICP</p>
<p>WEEK 1 notes:<br>这周主要是sbt、idea插件等环境准备，然后通过几个案例简单介绍下Scala的语法</p>
<ul>
<li>环境准备: jdk1.8, sbt0.13.x</li>
<li>Evaluation Rules: call by value, call by name</li>
<li>牛顿迭代求平方根</li>
<li>尾递归<a id="more"></a>
</li>
</ul>
<h4 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ brew install sbt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 国内repo</span></span><br><span class="line">$ cat ~/.sbt/repositories</span><br><span class="line">[repositories]</span><br><span class="line"><span class="built_in">local</span></span><br><span class="line">osc: http://maven.oschina.net/content/groups/public/</span><br><span class="line">typesafe: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[<span class="built_in">type</span>]s/[artifact](-[classifier]).[ext], bootOnly</span><br><span class="line">sonatype-oss-releases</span><br><span class="line">maven-central</span><br><span class="line">sonatype-oss-snapshots</span><br><span class="line"></span><br><span class="line"><span class="comment"># idea插件, 使用：cd 工程目录 &amp;&amp; run `sbt gen-idea` &amp;&amp; import project in idea</span></span><br><span class="line">$ cat ~/.sbt/0.13/plugins/build.sbt</span><br><span class="line">addSbtPlugin(<span class="string">"com.github.mpeltonen"</span> % <span class="string">"sbt-idea"</span> % <span class="string">"1.6.0"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://www.scala-sbt.org/release/docs/Setup.html" target="_blank" rel="external">sbt setup</a></li>
<li><a href="https://github.com/mpeltonen/sbt-idea" target="_blank" rel="external">sbt idea</a></li>
<li><a href="https://plugins.jetbrains.com/plugin/?idea&amp;id=1347" target="_blank" rel="external">scala idea</a></li>
</ul>
<h4 id="Evaluation-Rules"><a href="#Evaluation-Rules" class="headerlink" title="Evaluation Rules"></a>Evaluation Rules</h4><ul>
<li>Call by value: evaluates the function arguments before calling the function</li>
<li>Call by name: evaluates the function first, and then evaluates the arguments if need be</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = x * x</span><br><span class="line"></span><br><span class="line"><span class="comment">// which faster?</span></span><br><span class="line">test(<span class="number">2</span>, <span class="number">3</span>)      <span class="comment">// same steps</span></span><br><span class="line">test(<span class="number">3</span>+<span class="number">4</span>, <span class="number">8</span>)    <span class="comment">// CBV</span></span><br><span class="line">test(<span class="number">7</span>, <span class="number">2</span>*<span class="number">4</span>)    <span class="comment">// CBN</span></span><br><span class="line">test(<span class="number">3</span>+<span class="number">4</span>, <span class="number">2</span>*<span class="number">4</span>)  <span class="comment">// same steps</span></span><br></pre></td></tr></table></figure>
<ul>
<li>If CBV evaluation of an expression e terminates, then CBN evaluation of e terminates, too</li>
<li>The other direction is not true</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = x</span><br><span class="line">test(<span class="number">1</span>, loop)   <span class="comment">// Under CBN --&gt; 1</span></span><br><span class="line">test(<span class="number">1</span>, loop)   <span class="comment">// Under CBV --&gt; Non-termination</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Scala normally use <code>call-by-value</code>, but if the type of a function parameter starts with <code>=&gt;</code> it uses <code>call-by-name</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span> </span>= <span class="number">2</span>      <span class="comment">// CBN, evaluated when called</span></span><br><span class="line"><span class="keyword">val</span> example = <span class="number">2</span>      <span class="comment">// CBV, evaluated immediately</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> example = <span class="number">2</span> <span class="comment">// evaluated once when needed</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span></span>(x: <span class="type">Double</span>)    <span class="comment">// call by value</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span></span>(x: =&gt; <span class="type">Double</span>) <span class="comment">// call by name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myFct</span></span>(bindings: <span class="type">Int</span>*) = &#123; ... &#125; <span class="comment">// bindings is a sequence of int, containing a varying # of arguments</span></span><br></pre></td></tr></table></figure>
<h4 id="SICP-Newton’s-method"><a href="#SICP-Newton’s-method" class="headerlink" title="SICP Newton’s method"></a>SICP Newton’s method</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x: <span class="type">Double</span>) = <span class="keyword">if</span> (x &lt; <span class="number">0</span>) -x <span class="keyword">else</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrtIter</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>): <span class="type">Double</span> =</span><br><span class="line">  <span class="keyword">if</span> (isGoodEnough(guess, x)) guess</span><br><span class="line">  <span class="keyword">else</span> sqrtIter(improve(guess, x), x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isGoodEnough</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>) =</span><br><span class="line">  abs(guess * guess - x) &lt; <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">improve</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>) =</span><br><span class="line">  (guess + x / guess) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span></span>(x: <span class="type">Double</span>) = sqrtIter(<span class="number">1.0</span>, x)</span><br></pre></td></tr></table></figure>
<p>the <code>isGoodEnough</code> test is not very precise for small numbers and lead to Non-termination for very large numbers.</p>
<ul>
<li>0.001</li>
<li>0.1e-20</li>
<li>1.0e20</li>
<li>1.0e50</li>
</ul>
<p>the improved <code>isGoodEnough</code><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isGoodEnough</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>) =</span><br><span class="line">  abs(guess * guess - x) / x &lt; <span class="number">0.001</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Blocks-and-Lexical-Scope"><a href="#Blocks-and-Lexical-Scope" class="headerlink" title="Blocks and Lexical Scope"></a>Blocks and Lexical Scope</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x: <span class="type">Double</span>) = <span class="keyword">if</span> (x &lt; <span class="number">0</span>) -x <span class="keyword">else</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span></span>(x: <span class="type">Double</span>) = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sqrtIter</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>): <span class="type">Double</span> =</span><br><span class="line">    <span class="keyword">if</span> (isGoodEnough(guess, x)) guess</span><br><span class="line">    <span class="keyword">else</span> sqrtIter(improve(guess, x), x)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isGoodEnough</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>) =</span><br><span class="line">    abs(guess * guess - x) / x &lt; <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">improve</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>) =</span><br><span class="line">    (guess + x / guess) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  sqrtIter(<span class="number">1.0</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>much cleaner<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x: <span class="type">Double</span>) = <span class="keyword">if</span> (x &lt; <span class="number">0</span>) -x <span class="keyword">else</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqrt</span></span>(x: <span class="type">Double</span>) = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sqrtIter</span></span>(guess: <span class="type">Double</span>): <span class="type">Double</span> =</span><br><span class="line">    <span class="keyword">if</span> (isGoodEnough(guess)) guess</span><br><span class="line">    <span class="keyword">else</span> sqrtIter(improve(guess))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isGoodEnough</span></span>(guess: <span class="type">Double</span>) =</span><br><span class="line">    abs(guess * guess - x) / x &lt; <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">improve</span></span>(guess: <span class="type">Double</span>) =</span><br><span class="line">    (guess + x / guess) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  sqrtIter(<span class="number">1.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Tail-Recursion"><a href="#Tail-Recursion" class="headerlink" title="Tail Recursion"></a>Tail Recursion</h4><p>If a function calls itself as its last action, the function’s stack frame can be reused.<br>参照SICP 1.2节，递归计算过程的两种形式</p>
<ul>
<li>linear recursive process 线性递归计算过程<br>构造阶段会形成一个很长的链条，收缩阶段再执行具体计算操作</li>
<li>iterative process 迭代计算过程<br>常量空间中执行迭代计算，即使这一计算是用递归过程描述的</li>
</ul>
<p><code>Tail recursive functions are iterative processes.</code></p>
<div class="tip"><br>不要混淆recursive process(递归计算过程)和recursive procedure(递归过程)；递归过程只是一个概念，而它的进展方式可以是迭代的，也可以是线性递归的<br></div>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tail Recursion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(a: <span class="type">Int</span>, b:<span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) a <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not Tail Recursion, the expression gets bigger and bigger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>Tail Recursion in Scala<br>尾递归一直被当做一种编译技巧，有了尾递归的实现，就可以用常规的调用机制表述迭代，所以能使各种复杂的专用迭代结构包装成各种语法糖；比如Scala <code>@tailrec</code>编译器优化尾递归，如果实现方法不是尾递归会报异常<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a tail recursive version of factorial</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorialTailRecursion</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(acc: <span class="type">Int</span>, n: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) acc</span><br><span class="line">    <span class="keyword">else</span> loop(acc * n, n<span class="number">-1</span>)</span><br><span class="line">  loop(<span class="number">1</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/closures-currying-partials/" class="prev">PREV</a><a href="/2016/ssh-local-forwarding/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://michaelhuang.github.io">huangzhf</a>, <a href="https://github.com/pinggod/hexo-theme-apollo">apollo</a>, <a href="http://hexo.io">hexo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-75326623-1",'auto');ga('send','pageview');</script></body></html>